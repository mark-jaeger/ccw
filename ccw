#!/bin/bash
# ccw - Claude Code Worktree manager
#
# Usage:
#   ccw create <name>   Create worktree and start Claude Code
#   ccw open [name]     Open existing worktree (interactive if no name)
#   ccw list            List all worktrees for current repo
#   ccw remove <name>   Remove worktree (checks if merged first)
#   ccw cleanup         Remove all merged worktrees

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Config
CONFIG_FILE="$HOME/.config/ccw/config"
DANGEROUS_MODE=false

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

load_config

# Get repo root and name
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)" || {
    echo -e "${RED}Error: Not in a git repository${NC}"
    exit 1
}
REPO_NAME="$(basename "$REPO_ROOT")"
WORKTREE_BASE="$HOME/worktrees/$REPO_NAME"

cmd_create() {
    local name="$1"
    if [ -z "$name" ]; then
        echo "Usage: ccw create <worktree-name>"
        exit 1
    fi

    local worktree_path="$WORKTREE_BASE/$name"
    local branch_name="feature/$name"

    mkdir -p "$WORKTREE_BASE"

    if [ -d "$worktree_path" ]; then
        echo -e "${YELLOW}Worktree already exists${NC}"
    else
        echo -e "Creating worktree ${GREEN}$name${NC}..."
        git worktree add "$worktree_path" -b "$branch_name"

        # Copy .env if exists
        [ -f "$REPO_ROOT/.env" ] && cp "$REPO_ROOT/.env" "$worktree_path/.env"

        # Install dependencies if package.json exists
        if [ -f "$worktree_path/package.json" ]; then
            echo "Installing dependencies..."
            (cd "$worktree_path" && npm install --silent)
        fi

        echo -e "${GREEN}✓${NC} Created: $worktree_path"
        echo -e "${GREEN}✓${NC} Branch: $branch_name"
    fi

    echo ""
    echo "Starting Claude Code..."
    if [ "$DANGEROUS_MODE" = true ]; then
        cd "$worktree_path" && claude --dangerously-skip-permissions
    else
        cd "$worktree_path" && claude
    fi
}

cmd_list() {
    echo -e "${GREEN}Worktrees for $REPO_NAME:${NC}"
    echo ""

    local found=0
    while IFS= read -r line; do
        local wt_path=$(echo "$line" | awk '{print $1}')
        if [[ "$wt_path" == "$WORKTREE_BASE"/* ]]; then
            echo "$line"
            ((found++))
        fi
    done < <(git worktree list)

    if [ $found -eq 0 ]; then
        echo "  (none)"
    fi
}

cmd_open() {
    local name="$1"
    local worktree_path

    if [ -n "$name" ]; then
        # Direct open by name
        worktree_path="$WORKTREE_BASE/$name"
        if [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found:${NC} $worktree_path"
            echo ""
            echo "Available worktrees:"
            for wt in "$WORKTREE_BASE"/*/; do
                [ -d "$wt" ] && echo "  $(basename "$wt")"
            done
            exit 1
        fi
    else
        # Interactive selection
        local worktrees=()
        local paths=()

        # Get worktrees for this repo (skip the main repo itself)
        while IFS= read -r line; do
            local wt_path=$(echo "$line" | awk '{print $1}')
            # Only include worktrees under our worktree base
            if [[ "$wt_path" == "$WORKTREE_BASE"/* ]]; then
                worktrees+=("$(basename "$wt_path")")
                paths+=("$wt_path")
            fi
        done < <(git worktree list)

        if [ ${#worktrees[@]} -eq 0 ]; then
            echo -e "${YELLOW}No worktrees found for $REPO_NAME${NC}"
            echo "Create one with: ccw create <name>"
            exit 1
        fi

        local selected=0
        local total=${#worktrees[@]}

        # Hide cursor
        tput civis
        trap 'tput cnorm' EXIT

        while true; do
            # Move cursor to top and redraw
            tput cup 0 0
            tput ed
            echo -e "${GREEN}Select worktree to open:${NC}"
            echo ""

            for i in "${!worktrees[@]}"; do
                if [ $i -eq $selected ]; then
                    echo -e "  ${GREEN}▸ ${worktrees[$i]}${NC}"
                else
                    echo "    ${worktrees[$i]}"
                fi
            done

            echo ""
            echo -e "${YELLOW}↑/↓${NC} navigate  ${YELLOW}Enter${NC} select  ${YELLOW}q${NC} quit"

            # Read single keypress
            read -rsn1 key

            case "$key" in
                $'\x1b') # Escape sequence start
                    read -rsn2 -t 1 escape
                    case "$escape" in
                        '[A') # Up arrow
                            ((selected--)) || true
                            [ $selected -lt 0 ] && selected=$((total - 1))
                            ;;
                        '[B') # Down arrow
                            ((selected++)) || true
                            [ $selected -ge $total ] && selected=0
                            ;;
                    esac
                    ;;
                '') # Enter
                    tput cnorm
                    tput ed
                    worktree_path="${paths[$selected]}"
                    name="${worktrees[$selected]}"
                    break
                    ;;
                q|Q)
                    tput cnorm
                    tput ed
                    exit 0
                    ;;
            esac
        done
    fi

    echo -e "Opening ${GREEN}$name${NC}..."
    if [ "$DANGEROUS_MODE" = true ]; then
        cd "$worktree_path" && claude --dangerously-skip-permissions
    else
        cd "$worktree_path" && claude
    fi
}

cmd_remove() {
    local name="$1"
    if [ -z "$name" ]; then
        echo "Usage: ccw remove <worktree-name>"
        exit 1
    fi

    local worktree_path="$WORKTREE_BASE/$name"
    local branch_name="feature/$name"

    if [ ! -d "$worktree_path" ]; then
        echo -e "${RED}Worktree not found:${NC} $worktree_path"
        exit 1
    fi

    # Check if branch is merged into main or staging
    local merged=""
    if git branch --merged main 2>/dev/null | grep -q "$branch_name"; then
        merged="main"
    elif git branch --merged staging 2>/dev/null | grep -q "$branch_name"; then
        merged="staging"
    fi

    if [ -n "$merged" ]; then
        echo -e "${GREEN}✓${NC} Branch is merged into $merged"
        git worktree remove "$worktree_path"
        git branch -d "$branch_name" 2>/dev/null || true
        echo -e "${GREEN}✓${NC} Removed worktree and branch"
    else
        echo -e "${YELLOW}⚠${NC} Branch is NOT merged"
        echo ""
        read -p "Remove anyway? (y/N) " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            git worktree remove --force "$worktree_path"
            read -p "Also delete branch $branch_name? (y/N) " del_branch
            if [[ "$del_branch" =~ ^[Yy]$ ]]; then
                git branch -D "$branch_name"
            fi
            echo -e "${GREEN}✓${NC} Removed"
        else
            echo "Cancelled"
        fi
    fi
}

cmd_cleanup() {
    echo -e "Cleaning up merged worktrees for ${GREEN}$REPO_NAME${NC}..."
    echo ""

    local removed=0

    for worktree_path in "$WORKTREE_BASE"/*/; do
        [ -d "$worktree_path" ] || continue

        # Remove trailing slash for comparison
        worktree_path="${worktree_path%/}"

        local name="$(basename "$worktree_path")"
        local branch_name="feature/$name"

        # Skip if not a valid worktree
        git worktree list | grep -q "$worktree_path" || continue

        # Check if merged
        if git branch --merged main 2>/dev/null | grep -q "$branch_name" || \
           git branch --merged staging 2>/dev/null | grep -q "$branch_name"; then
            echo -e "Removing ${GREEN}$name${NC} (merged)"
            git worktree remove "$worktree_path" 2>/dev/null || true
            git branch -d "$branch_name" 2>/dev/null || true
            ((removed++))
        else
            echo -e "Keeping ${YELLOW}$name${NC} (not merged)"
        fi
    done

    echo ""
    echo -e "${GREEN}✓${NC} Removed $removed merged worktree(s)"
}

cmd_config() {
    local key="$1"
    local value="$2"

    if [ -z "$key" ]; then
        echo "Current config ($CONFIG_FILE):"
        echo ""
        if [ -f "$CONFIG_FILE" ]; then
            cat "$CONFIG_FILE"
        else
            echo "  (no config file)"
        fi
        echo ""
        echo "Available options:"
        echo "  DANGEROUS_MODE=true    Launch Claude with --dangerously-skip-permissions"
        return
    fi

    # Create config directory if needed
    mkdir -p "$(dirname "$CONFIG_FILE")"

    if [ -z "$value" ]; then
        # Show current value
        if [ -f "$CONFIG_FILE" ] && grep -q "^$key=" "$CONFIG_FILE"; then
            grep "^$key=" "$CONFIG_FILE"
        else
            echo "$key is not set"
        fi
    else
        # Set value
        if [ -f "$CONFIG_FILE" ] && grep -q "^$key=" "$CONFIG_FILE"; then
            # Update existing
            sed -i '' "s/^$key=.*/$key=$value/" "$CONFIG_FILE"
        else
            # Append new
            echo "$key=$value" >> "$CONFIG_FILE"
        fi
        echo -e "${GREEN}✓${NC} Set $key=$value"
    fi
}

cmd_help() {
    echo "ccw - Claude Code Worktree manager"
    echo ""
    echo "Usage:"
    echo "  ccw create <name>   Create worktree and start Claude Code"
    echo "  ccw open [name]     Open existing worktree (interactive if no name)"
    echo "  ccw list            List all worktrees for current repo"
    echo "  ccw remove <name>   Remove worktree (checks if merged first)"
    echo "  ccw cleanup         Remove all merged worktrees"
    echo "  ccw config [key] [value]  View or set configuration"
    echo ""
    echo "Worktrees are created in: ~/worktrees/<repo-name>/<name>"
    echo "Branches are named: feature/<name>"
    echo ""
    echo "Config file: ~/.config/ccw/config"
}

# Main
case "${1:-}" in
    create)  cmd_create "$2" ;;
    open)    cmd_open "$2" ;;
    list)    cmd_list ;;
    remove)  cmd_remove "$2" ;;
    cleanup) cmd_cleanup ;;
    config)  cmd_config "$2" "$3" ;;
    help|-h|--help) cmd_help ;;
    "")      cmd_open ;;
    *)
        cmd_help
        exit 1
        ;;
esac
